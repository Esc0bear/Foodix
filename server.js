const express = require('express');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
const Joi = require('joi');
require('dotenv').config();

const app = express();
const PORT = process.env.PORT || 3000;

// üîí Configuration s√©curit√©
app.set('trust proxy', 1);
app.use(helmet({
  crossOriginEmbedderPolicy: false
}));

// üåê Configuration CORS
app.use(cors({
  origin: ['https://gaby-app.com', 'http://localhost:3000'],
  credentials: true
}));

// üö´ Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  message: { error: 'Trop de requ√™tes, r√©essayez plus tard.' },
  standardHeaders: true,
  legacyHeaders: false,
});
app.use('/api/', limiter);

// üìù Parsing JSON
app.use(express.json({ limit: '10mb' }));

// üîê Middleware d'authentification
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) {
    return res.status(401).json({ error: 'Token d\'acc√®s requis' });
  }
  
  if (token !== process.env.GABY_AUTH_TOKEN) {
    return res.status(403).json({ error: 'Token invalide' });
  }
  
  next();
};

// üß† Service OpenAI
const OpenAI = require('openai');
const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY
});

// üìã Sch√©mas de validation
const conversationAnalysisSchema = Joi.object({
  ocrResults: Joi.array().items(Joi.string()).required(),
  profile: Joi.object({
    name: Joi.string().required(),
    gender: Joi.string().valid('male', 'female', 'other').required()
  }).required(),
  userComment: Joi.string().allow(''),
  shouldSuggestResponse: Joi.boolean().default(false),
  type: Joi.string().valid('conversation_analysis').required(),
  source: Joi.string().valid('ocr', 'import').optional()
});

const chatSchema = Joi.object({
  message: Joi.string().required(),
  context: Joi.string().allow(''),
  image_base64: Joi.string().allow(''),
  type: Joi.string().valid('chat').required()
});

// üè† Route de sant√©
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    service: 'Gaby Backend',
    timestamp: new Date().toISOString()
  });
});

// üç≥ NOUVEAUX ENDPOINTS POUR LES RECETTES
// Route de g√©n√©ration de recette
app.post('/generate-recipe', async (req, res) => {
  try {
    console.log('üç≥ [RECIPE] Nouvelle demande de g√©n√©ration de recette');
    const { platform, url, author, caption, thumbnail } = req.body;
    
    console.log('üìù [RECIPE] Donn√©es re√ßues:', {
      platform,
      url,
      author,
      captionLength: caption?.length || 0,
      thumbnail: thumbnail ? 'Pr√©sent' : 'Absent'
    });

    const systemPrompt = `Tu es un expert culinaire. G√©n√®re une recette compl√®te au format JSON strict:

{
  "id": "uuid-g√©n√©r√©",
  "createdAt": "2025-09-17T13:00:00.000Z",
  "title": "Titre de la recette",
  "summary": "Description courte et app√©tissante",
  "servings": 4,
  "time": {"prep": 15, "cook": 30, "total": 45},
  "difficulty": "easy|medium|hard",
  "ingredients": [{"item": "Nom de l'ingr√©dient", "quantity": 200, "unit": "g", "notes": null}],
  "instructions": [{"step": 1, "text": "Description d√©taill√©e de l'√©tape"}],
  "nutrition": {"calories": 350, "protein": 25, "carbs": 30, "fat": 15},
  "proTips": ["Conseil de pro 1", "Conseil de pro 2"],
  "source": {"platform": "instagram", "url": "URL originale", "author": "Auteur", "thumbnail": "URL de l'image"}
}`;

    const userPrompt = `G√©n√®re une recette compl√®te √† partir de ces informations:

Plateforme: ${platform}
URL: ${url}
Auteur: ${author || 'Inconnu'}
Description: ${caption}
Image: ${thumbnail || 'Aucune'}

Cr√©e une recette d√©taill√©e, app√©tissante et facile √† suivre.`;

    console.log('üß† [RECIPE] Envoi √† OpenAI...');
    
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt }
      ],
      max_tokens: 2000,
      temperature: 0.7,
    });

    let recipeJson = completion.choices[0].message.content;
    recipeJson = recipeJson.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    
    let recipe = JSON.parse(recipeJson);
    recipe.id = require('crypto').randomUUID();
    recipe.createdAt = new Date().toISOString();
    
    console.log('‚úÖ [RECIPE] Recette g√©n√©r√©e avec succ√®s:', {
      id: recipe.id,
      title: recipe.title,
      ingredientsCount: recipe.ingredients.length,
      instructionsCount: recipe.instructions.length
    });
    
    res.json(recipe);

  } catch (error) {
    console.error('‚ùå [RECIPE] Erreur lors de la g√©n√©ration:', error);
    
    if (error.code === 'insufficient_quota') {
      return res.status(402).json({ 
        error: 'Quota OpenAI insuffisant' 
      });
    }
    
    if (error.code === 'rate_limit_exceeded') {
      return res.status(429).json({ 
        error: 'Limite de taux OpenAI d√©pass√©e, r√©essayez dans quelques instants' 
      });
    }
    
    res.status(500).json({ 
      error: 'Erreur interne du serveur',
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Route de reformulation de recette
app.post('/reformulate-recipe', async (req, res) => {
  try {
    console.log('‚ú® [REFORMULATE] Nouvelle demande de reformulation');
    const { recipeId, reformulationType } = req.body;
    
    console.log('üîÑ [REFORMULATE] Param√®tres:', { recipeId, reformulationType });

    const prompts = {
      simplify: "Simplifie cette recette pour la rendre plus accessible aux d√©butants. Utilise des termes simples, r√©duis le nombre d'ingr√©dients si possible, et donne des instructions tr√®s claires.",
      detailed: "D√©taille davantage cette recette en ajoutant plus d'explications, de conseils techniques, et de variantes. Rends-la plus professionnelle et compl√®te.",
      professional: "Reformule cette recette dans un style de chef professionnel. Utilise un vocabulaire technique pr√©cis, des techniques avanc√©es, et un ton expert.",
      casual: "Reformule cette recette dans un style d√©contract√© et amical. Utilise un langage familier, des expressions courantes, et un ton chaleureux."
    };

    const systemPrompt = `Tu es un expert culinaire qui reformule des recettes selon diff√©rents styles.

Style demand√©: ${reformulationType}
Instructions: ${prompts[reformulationType]}

R√àGLES:
1. Garde la m√™me structure JSON que la recette originale
2. Adapte le contenu selon le style demand√©
3. Conserve toutes les informations essentielles
4. Am√©liore la clart√© et l'accessibilit√©
5. Garde le m√™me ID et timestamp

FORMAT DE R√âPONSE: JSON strict identique √† la recette originale`;

    const userPrompt = `Reformule cette recette (ID: ${recipeId}) selon le style "${reformulationType}".

Note: Pour cette d√©mo, g√©n√®re une recette exemple de g√¢teau au chocolat que tu reformuleras selon le style demand√©.`;

    console.log('üß† [REFORMULATE] Envoi √† OpenAI...');
    
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt }
      ],
      max_tokens: 2000,
      temperature: 0.7,
    });

    let recipeJson = completion.choices[0].message.content;
    recipeJson = recipeJson.replace(/```json\n?/g, '').replace(/```\n?/g, '').trim();
    
    let recipe = JSON.parse(recipeJson);
    recipe.id = recipeId;
    recipe.createdAt = new Date().toISOString();
    
    console.log('‚úÖ [REFORMULATE] Recette reformul√©e avec succ√®s:', {
      id: recipe.id,
      title: recipe.title,
      reformulationType
    });
    
    res.json(recipe);

  } catch (error) {
    console.error('‚ùå [REFORMULATE] Erreur lors de la reformulation:', error);
    
    if (error.code === 'insufficient_quota') {
      return res.status(402).json({ 
        error: 'Quota OpenAI insuffisant' 
      });
    }
    
    if (error.code === 'rate_limit_exceeded') {
      return res.status(429).json({ 
        error: 'Limite de taux OpenAI d√©pass√©e, r√©essayez dans quelques instants' 
      });
    }
    
    res.status(500).json({ 
      error: 'Erreur interne du serveur',
      details: error.message,
      timestamp: new Date().toISOString()
    });
  }
});

// Route de test pour les recettes
app.get('/test-recipe', (req, res) => {
  res.json({ 
    status: 'OK', 
    service: 'Recipe Service',
    endpoints: ['/generate-recipe', '/reformulate-recipe'],
    timestamp: new Date().toISOString()
  });
});

// üîç Route d'analyse de conversation (GABY)
app.post('/api/analyze', authenticateToken, async (req, res) => {
  try {
    console.log('üì• Nouvelle demande d\'analyse re√ßue');
    
    const { error, value } = conversationAnalysisSchema.validate(req.body);
    if (error) {
      return res.status(400).json({ 
        error: 'Donn√©es invalides', 
        details: error.details[0].message 
      });
    }

    const { ocrResults, profile, userComment, shouldSuggestResponse, source } = value;
    
    const responseInstructions = shouldSuggestResponse 
      ? `1. Une analyse compl√®te du ton et des intentions
2. Des conseils de r√©ponse concrets
3. Une √©valuation du niveau d'int√©r√™t du crush
4. Des red flags √©ventuels
5. Des recommandations pour la suite`
      : `Note: Compte tenu du fait que l'utilisateur n'a pas demand√© de suggestions de r√©ponse, je ne propose pas de conseils de r√©ponse concrets √† ces messages.

1. Une analyse compl√®te du ton et des intentions
2. Une √©valuation du niveau d'int√©r√™t du crush
3. Des red flags √©ventuels
4. Des recommandations pour la suite`;
    
    const baseRulesAnalyze = `R√àGLES PRIORITAIRES:\n` +
      `1) Tutoie TOUJOURS la personne (tu/ton/ta/tes). Jamais de vouvoiement.\n` +
      `2) N'emploie JAMAIS le terme "l'utilisateur" pour parler √† la personne. Adresse-toi directement (ex: \"tu peux\", \"je te conseille\").\n` +
      `3) N'utilise pas le pr√©nom du crush pour t'adresser √† la personne (pas de \"Pr√©nom, ...\" en t√™te).\n` +
      `4) Ton ton est proche, empathique et concret (meilleure amie psy).`;

    const ocrStyleRules = (source === 'ocr')
      ? `\n\nConsignes de style (OCR):\n- Adresse-toi uniquement √† l'utilisateur en le tutoyant ("tu").\n- Ne donne jamais de consignes au/√† la crush; parle d'elle/lui √† la 3e personne.\n- Ne parle jamais de l'utilisateur √† la 3e personne (√©vite ¬´ la personne ¬ª pour le lecteur).\n- Si tu utilises ¬´ la personne ¬ª, cela d√©signe le/la crush (pas le lecteur).\n- Reste coh√©rent du d√©but √† la fin.`
      : '';

    const systemPrompt = `${baseRulesAnalyze}\n\nTu es Gaby, l'assistante relationnelle experte. Tu analyses les conversations pour donner des conseils sur les relations amoureuses.${ocrStyleRules}

Contexte:
- Nom du crush: ${profile.name}
- Genre: ${profile.gender}
- Commentaire utilisateur: ${userComment || 'Aucun commentaire sp√©cifique'}
- Suggestions de r√©ponse demand√©es: ${shouldSuggestResponse ? 'Oui' : 'Non'}

Analyse cette conversation et fournis:
${responseInstructions}

Sois empathique, pr√©cise et donne des conseils pratiques.`;

    const userPrompt = `Voici les textes extraits de la conversation (dans l'ordre chronologique):

${ocrResults.map((text, index) => `--- Message ${index + 1} ---\n${text}`).join('\n\n')}

Analyse cette conversation en d√©tail.`;

    console.log('üß† Envoi √† OpenAI...');
    
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userPrompt }
      ],
      max_tokens: 1200,
      temperature: 0.7,
    });

    let analysis = completion.choices[0].message.content;

    analysis = analysis
      .replace(/\bl['']utilisateur\b/gi, 'toi')
      .replace(/\butilisateur\b/gi, 'toi')
      .replace(/\bvous\b/gi, 'tu')
      .replace(/\bvos\b/gi, 'tes')
      .replace(/\bvotre\b/gi, 'ton/ta');
    
    console.log('‚úÖ Analyse termin√©e avec succ√®s');
    
    res.json({
      success: true,
      analysis: analysis,
      timestamp: new Date().toISOString(),
      messageCount: ocrResults.length
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de l\'analyse:', error);
    
    if (error.code === 'insufficient_quota') {
      return res.status(402).json({ 
        error: 'Quota OpenAI insuffisant' 
      });
    }
    
    if (error.code === 'rate_limit_exceeded') {
      return res.status(429).json({ 
        error: 'Limite de taux OpenAI d√©pass√©e, r√©essayez dans quelques instants' 
      });
    }
    
    res.status(500).json({ 
      error: 'Erreur interne du serveur',
      timestamp: new Date().toISOString()
    });
  }
});

// üí¨ Route de chat avec Gaby
app.post('/api/chat', authenticateToken, async (req, res) => {
  try {
    console.log('üí¨ Nouvelle conversation avec Gaby');
    
    const { error, value } = chatSchema.validate(req.body);
    if (error) {
      return res.status(400).json({ 
        error: 'Donn√©es invalides', 
        details: error.details[0].message 
      });
    }

    const { message, context, image_base64 } = value;
    
    const baseRules = `R√àGLES PRIORITAIRES:
1) Tu tutoies TOUJOURS l'utilisateur. Jamais de vouvoiement.
2) Tu ne t'adresses JAMAIS √† l'utilisateur en utilisant le pr√©nom du crush. N'utilise pas de pr√©nom en en-t√™te (ex: "Margot, ..."). Pr√©f√®re des formulations neutres ("ok", "je te propose", "si tu veux...").
3) Ton ton est celui d'une meilleure amie psychologue: empathique, direct, constructif, sans jugement.`;
    
    const systemPrompt = (context && context.trim().length > 0)
      ? `${baseRules}\n\n${context}`
      : `${baseRules}\n\nTu es Gaby, une assistante relationnelle bienveillante et objective. Tu r√©ponds de fa√ßon naturelle et empathique tout en restant neutre.

Ton style:
- R√©ponses NATURELLES et BIENVEILLANTES (2-4 phrases)
- TUTOIE TOUJOURS l'utilisateur (utilise "tu", jamais "vous")
- OBJECTIVE et √âQUILIBR√âE, tu pr√©sentes les faits sans jugement
- EMPATHIQUE mais R√âALISTE, tu comprends les √©motions sans les valider aveugl√©ment
- Tu identifies les signaux positifs ET n√©gatifs de fa√ßon neutre
- Tu poses des questions de clarification quand tu manques d'√©l√©ments
- Tu alimentes la conversation en proposant des pistes de r√©flexion
- Tu ne r√©ponds qu'aux questions li√©es aux relations et √† la communication

Apr√®s avoir r√©pondu √† la question principale, tu peux:
- Poser une question pour approfondir la situation
- Sugg√©rer un angle d'analyse diff√©rent
- Proposer une prochaine √©tape concr√®te

IMPORTANT: Tu TUTOIES TOUJOURS, m√™me si le contexte sugg√®re le contraire.
Tu restes factuelle et constructive, sans complaisance ni pessimisme excessif.`;

    const userContent = (image_base64 && String(image_base64).trim().length > 0)
      ? [
          { type: 'text', text: String(message) },
          { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${image_base64}` } }
        ]
      : String(message);

    if (Array.isArray(userContent)) {
      console.log('üñºÔ∏è [CHAT] Vision activ√©e sur /api/chat (image + prompt)');
    }

    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "system", content: systemPrompt },
        { role: "user", content: userContent }
      ],
      max_tokens: 1000,
      temperature: 0.8,
    });

    let response = completion.choices[0].message.content;
    
    response = response
      .replace(/\bvous\b/gi, 'tu')
      .replace(/\bvotre\b/gi, 'ton/ta')
      .replace(/\bvos\b/gi, 'tes')
      .replace(/\b√™tes\b/gi, 'es')
      .replace(/\bavez\b/gi, 'as')
      .replace(/\bpouvez\b/gi, 'peux')
      .replace(/\bvoulez\b/gi, 'veux')
      .replace(/\bfaites\b/gi, 'fais')
      .replace(/\bdites\b/gi, 'dis')
      .replace(/\bvous aviez\b/gi, 'tu avais')
      .replace(/\bvous √©tiez\b/gi, 'tu √©tais')
      .replace(/\bvous devriez\b/gi, 'tu devrais')
      .replace(/\bvous pourriez\b/gi, 'tu pourrais');

    response = response.replace(/^[A-Z√Ä-√ñ√ò-√û][a-z√†-√∂√∏-√ø]+\s*[,|:]\s+(?=\S)/, '');
    
    console.log('‚úÖ R√©ponse de Gaby g√©n√©r√©e et corrig√©e (tutoiement forc√©)');
    
    res.json({
      success: true,
      response: response,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Erreur lors du chat:', error);
    res.status(500).json({ 
      error: 'Erreur interne du serveur',
      timestamp: new Date().toISOString()
    });
  }
});

// üí¨ Endpoint pour la g√©n√©ration de r√©ponses
app.post('/api/generate-responses', authenticateToken, async (req, res) => {
  try {
    console.log('‚ú® Nouvelle demande de g√©n√©ration de r√©ponses');
    
    const { prompt, tone, max_tokens = 1000 } = req.body;
    
    if (!prompt || !tone) {
      return res.status(400).json({ 
        error: 'Prompt et tone requis' 
      });
    }
    
    console.log(`üé≠ Ton demand√©: ${tone}`);
    console.log(`üìù Prompt: ${prompt.substring(0, 100)}...`);
    
    const completion = await openai.chat.completions.create({
      model: "gpt-4o-mini",
      messages: [
        { role: "user", content: prompt }
      ],
      max_tokens: max_tokens,
      temperature: 0.8,
    });

    const response = completion.choices[0].message.content;
    
    const responses = response.split('###')
      .map(r => r.trim())
      .filter(r => r.length > 0)
      .slice(0, 3);
    
    while (responses.length < 3) {
      responses.push(`R√©ponse ${responses.length + 1} g√©n√©r√©e automatiquement.`);
    }
    
    console.log(`‚úÖ ${responses.length} r√©ponses g√©n√©r√©es avec succ√®s`);
    
    res.json({
      success: true,
      responses: responses,
      tone: tone,
      timestamp: new Date().toISOString()
    });

  } catch (error) {
    console.error('‚ùå Erreur lors de la g√©n√©ration de r√©ponses:', error);
    
    const fallbackResponses = getFallbackResponses(req.body.tone || 'friendly');
    
    res.json({
      success: true,
      responses: fallbackResponses,
      tone: req.body.tone || 'friendly',
      fallback: true,
      timestamp: new Date().toISOString()
    });
  }
});

// üñºÔ∏è Endpoint vision pour g√©n√©ration de r√©ponses √† partir d'un screenshot
app.post('/api/generate-responses-vision', authenticateToken, async (req, res) => {
  try {
    console.log('üñºÔ∏è Nouvelle demande de g√©n√©ration (VISION)');

    const { image_base64, prompt, tone, max_tokens = 1000 } = req.body;

    if (!image_base64 || !prompt || !tone) {
      return res.status(400).json({ error: 'image_base64, prompt et tone sont requis' });
    }

    console.log(`üé≠ Ton demand√©: ${tone}`);
    console.log(`üìù Prompt: ${String(prompt).substring(0, 100)}...`);

    const userContent = [
      { type: 'text', text: String(prompt) },
      { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${image_base64}` } }
    ];

    const completion = await openai.chat.completions.create({
      model: 'gpt-4o-mini',
      messages: [
        { role: 'user', content: userContent }
      ],
      max_tokens: max_tokens,
      temperature: 0.8,
    });

    const response = completion.choices?.[0]?.message?.content || '';

    const responses = String(response).split('###')
      .map(r => r.trim())
      .filter(r => r.length > 0)
      .slice(0, 3);

    while (responses.length < 3) {
      responses.push(`R√©ponse ${responses.length + 1} g√©n√©r√©e automatiquement.`);
    }

    console.log(`‚úÖ ${responses.length} r√©ponses VISION g√©n√©r√©es avec succ√®s`);
    res.json({
      success: true,
      responses,
      tone,
      timestamp: new Date().toISOString()
    });
  } catch (error) {
    console.error('‚ùå Erreur lors de la g√©n√©ration VISION:', error);
    res.status(500).json({ error: 'Erreur interne du serveur (vision)' });
  }
});

// Fonction helper pour les r√©ponses de fallback
function getFallbackResponses(tone) {
  const fallbacks = {
    friendly: [
      "C'est gentil de ta part ! Comment √ßa va de ton c√¥t√© ?",
      "Merci pour ton message üòä J'ai h√¢te de te r√©pondre plus longuement !",
      "Tu es adorable ! Raconte-moi comment s'est pass√©e ta journ√©e ?"
    ],
    flirty: [
      "Tu sais exactement quoi dire pour me faire sourire üòè",
      "Mmh... j'aime cette attention que tu me portes üòò",
      "Tu es en train de devenir irr√©sistible, tu le sais √ßa ? üòâ"
    ],
    confident: [
      "J'appr√©cie ta franchise. Moi aussi j'ai quelque chose √† te dire...",
      "Tu as du caract√®re, j'aime √ßa. On devrait se voir bient√¥t.",
      "Direct et honn√™te, exactement comme j'aime. Respecte √ßa chez toi."
    ],
    playful: [
      "Oh l√† l√†, qu'est-ce que tu mijotes encore ? üòú",
      "Tu es en train de comploter quelque chose, je le sens ! ü§î",
      "Hmm... je vois o√π tu veux en venir, petit malin ! üòÑ"
    ],
    sincere: [
      "√áa me touche vraiment que tu partages √ßa avec moi.",
      "Je suis reconnaissante pour ta sinc√©rit√©. √áa compte beaucoup.",
      "Merci d'√™tre si authentique avec moi. C'est pr√©cieux."
    ],
    humorous: [
      "Haha ! Tu vas me faire mourir de rire üòÇ",
      "Attention, avec des blagues comme √ßa tu vas devenir irr√©sistible ! üòÑ",
      "Tu es vraiment en train d'essayer de me charmer avec ton humour ? √áa marche ! ü§£"
    ]
  };
  
  return fallbacks[tone] || fallbacks.friendly;
}

// üö´ Route par d√©faut
app.use('*', (req, res) => {
  res.status(404).json({ error: 'Endpoint non trouv√©' });
});

// üöÄ D√©marrage du serveur
app.listen(PORT, () => {
  console.log(`üöÄ Serveur Gaby d√©marr√© sur le port ${PORT}`);
  console.log(`üåç Environnement: ${process.env.NODE_ENV || 'development'}`);
  console.log(`üîê Auth configur√©e: ${process.env.GABY_AUTH_TOKEN ? '‚úÖ' : '‚ùå'}`);
  console.log(`üß† OpenAI configur√©: ${process.env.OPENAI_API_KEY ? '‚úÖ' : '‚ùå'}`);
});

// üí• Gestion des erreurs non captur√©es
process.on('uncaughtException', (error) => {
  console.error('üí• Erreur non captur√©e:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('üí• Promesse rejet√©e non g√©r√©e:', reason);
  process.exit(1);
});
